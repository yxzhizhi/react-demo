<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>   <!--读取json文献 -->
</head>
<body>

<canvas id="myCanvas" width="18850" height="5550" style="border:1px solid #000000;"> 你的浏览器不支持 canvas，请升级你的浏览器。</canvas>



<script type="text/javascript">
	//console.time('global')
	   var tree ={
 "name": "flare",
 "children": [
  {
   "name": "analytics",
   "children": [
    {
     "name": "cluster",
     "children": [
      {"name": "AgglomerativeCluster", "value": 3938},
      {"name": "CommunityStructure", "value": 3812},
      {"name": "HierarchicalCluster", "value": 6714},
      {"name": "MergeEdge", "value": 743}
     ]
    },
    {
     "name": "graph",
     "children": [
      {"name": "BetweennessCentrality", "value": 3534},
      {"name": "LinkDistance", "value": 5731},
      {"name": "MaxFlowMinCut", "value": 7840},
      {"name": "ShortestPaths", "value": 5914},
      {"name": "SpanningTree", "value": 3416}
     ]
    },
    {
     "name": "optimization",
     "children": [
      {"name": "AspectRatioBanker", "value": 7074}
     ]
    }
   ]
  },
  {
   "name": "animate",
   "children": [
    {"name": "Easing", "value": 17010},
    {"name": "FunctionSequence", "value": 5842},
    {
     "name": "interpolate",
     "children": [
      {"name": "ArrayInterpolator", "value": 1983},
      {"name": "ColorInterpolator", "value": 2047},
      {"name": "DateInterpolator", "value": 1375},
      {"name": "Interpolator", "value": 8746},
      {"name": "MatrixInterpolator", "value": 2202},
      {"name": "NumberInterpolator", "value": 1382},
      {"name": "ObjectInterpolator", "value": 1629},
      {"name": "PointInterpolator", "value": 1675},
      {"name": "RectangleInterpolator", "value": 2042}
     ]
    },
    {"name": "ISchedulable", "value": 1041},
    {"name": "Parallel", "value": 5176},
    {"name": "Pause", "value": 449},
    {"name": "Scheduler", "value": 5593},
    {"name": "Sequence", "value": 5534},
    {"name": "Transition", "value": 9201},
    {"name": "Transitioner", "value": 19975},
    {"name": "TransitionEvent", "value": 1116},
    {"name": "Tween", "value": 6006}
   ]
  },
  {
   "name": "data",
   "children": [
    {
     "name": "converters",
     "children": [
      {"name": "Converters", "value": 721},
      {"name": "DelimitedTextConverter", "value": 4294},
      {"name": "GraphMLConverter", "value": 9800},
      {"name": "IDataConverter", "value": 1314},
      {"name": "JSONConverter", "value": 2220}
     ]
    },
    {"name": "DataField", "value": 1759},
    {"name": "DataSchema", "value": 2165},
    {"name": "DataSet", "value": 586},
    {"name": "DataSource", "value": 3331},
    {"name": "DataTable", "value": 772},
    {"name": "DataUtil", "value": 3322}
   ]
  },
  {
   "name": "display",
   "children": [
    {"name": "DirtySprite", "value": 8833},
    {"name": "LineSprite", "value": 1732},
    {"name": "RectSprite", "value": 3623},
    {"name": "TextSprite", "value": 10066}
   ]
  },
  {
   "name": "flex",
   "children": [
    {"name": "FlareVis", "value": 4116}
   ]
  },
  {
   "name": "physics",
   "children": [
    {"name": "DragForce", "value": 1082},
    {"name": "GravityForce", "value": 1336},
    {"name": "IForce", "value": 319},
    {"name": "NBodyForce", "value": 10498},
    {"name": "Particle", "value": 2822},
    {"name": "Simulation", "value": 9983},
    {"name": "Spring", "value": 2213},
    {"name": "SpringForce", "value": 1681}
   ]
  },
  {
   "name": "query",
   "children": [
    {"name": "AggregateExpression", "value": 1616},
    {"name": "And", "value": 1027},
    {"name": "Arithmetic", "value": 3891},
    {"name": "Average", "value": 891},
    {"name": "BinaryExpression", "value": 2893},
    {"name": "Comparison", "value": 5103},
    {"name": "CompositeExpression", "value": 3677},
    {"name": "Count", "value": 781},
    {"name": "DateUtil", "value": 4141},
    {"name": "Distinct", "value": 933},
    {"name": "Expression", "value": 5130},
    {"name": "ExpressionIterator", "value": 3617},
    {"name": "Fn", "value": 3240},
    {"name": "If", "value": 2732},
    {"name": "IsA", "value": 2039},
    {"name": "Literal", "value": 1214},
    {"name": "Match", "value": 3748},
    {"name": "Maximum", "value": 843},
    {
     "name": "methods",
     "children": [
      {"name": "add", "value": 593},
      {"name": "and", "value": 330},
      {"name": "average", "value": 287},
      {"name": "count", "value": 277},
      {"name": "distinct", "value": 292},
      {"name": "div", "value": 595},
      {"name": "eq", "value": 594},
      {"name": "fn", "value": 460},
      {"name": "gt", "value": 603},
      {"name": "gte", "value": 625},
      {"name": "iff", "value": 748},
      {"name": "isa", "value": 461},
      {"name": "lt", "value": 597},
      {"name": "lte", "value": 619},
      {"name": "max", "value": 283},
      {"name": "min", "value": 283},
      {"name": "mod", "value": 591},
      {"name": "mul", "value": 603},
      {"name": "neq", "value": 599},
      {"name": "not", "value": 386},
      {"name": "or", "value": 323},
      {"name": "orderby", "value": 307},
      {"name": "range", "value": 772},
      {"name": "select", "value": 296},
      {"name": "stddev", "value": 363},
      {"name": "sub", "value": 600},
      {"name": "sum", "value": 280},
      {"name": "update", "value": 307},
      {"name": "variance", "value": 335},
      {"name": "where", "value": 299},
      {"name": "xor", "value": 354},
      {"name": "_", "value": 264}
     ]
    },
    {"name": "Minimum", "value": 843},
    {"name": "Not", "value": 1554},
    {"name": "Or", "value": 970},
    {"name": "Query", "value": 13896},
    {"name": "Range", "value": 1594},
    {"name": "StringUtil", "value": 4130},
    {"name": "Sum", "value": 791},
    {"name": "Variable", "value": 1124},
    {"name": "Variance", "value": 1876},
    {"name": "Xor", "value": 1101}
   ]
  },
  {
   "name": "scale",
   "children": [
    {"name": "IScaleMap", "value": 2105},
    {"name": "LinearScale", "value": 1316},
    {"name": "LogScale", "value": 3151},
    {"name": "OrdinalScale", "value": 3770},
    {"name": "QuantileScale", "value": 2435},
    {"name": "QuantitativeScale", "value": 4839},
    {"name": "RootScale", "value": 1756},
    {"name": "Scale", "value": 4268},
    {"name": "ScaleType", "value": 1821},
    {"name": "TimeScale", "value": 5833}
   ]
  },
  {
   "name": "util",
   "children": [
    {"name": "Arrays", "value": 8258},
    {"name": "Colors", "value": 10001},
    {"name": "Dates", "value": 8217},
    {"name": "Displays", "value": 12555},
    {"name": "Filter", "value": 2324},
    {"name": "Geometry", "value": 10993},
    {
     "name": "heap",
     "children": [
      {"name": "FibonacciHeap", "value": 9354},
      {"name": "HeapNode", "value": 1233}
     ]
    },
    {"name": "IEvaluable", "value": 335},
    {"name": "IPredicate", "value": 383},
    {"name": "IValueProxy", "value": 874},
    {
     "name": "math",
     "children": [
      {"name": "DenseMatrix", "value": 3165},
      {"name": "IMatrix", "value": 2815},
      {"name": "SparseMatrix", "value": 3366}
     ]
    },
    {"name": "Maths", "value": 17705},
    {"name": "Orientation", "value": 1486},
    {
     "name": "palette",
     "children": [
      {"name": "ColorPalette", "value": 6367},
      {"name": "Palette", "value": 1229},
      {"name": "ShapePalette", "value": 2059},
      {"name": "SizePalette", "value": 2291}
     ]
    },
    {"name": "Property", "value": 5559},
    {"name": "Shapes", "value": 19118},
    {"name": "Sort", "value": 6887},
    {"name": "Stats", "value": 6557},
    {"name": "Strings", "value": 22026}
   ]
  },
  {
   "name": "vis",
   "children": [
    {
     "name": "axis",
     "children": [
      {"name": "Axes", "value": 1302},
      {"name": "Axis", "value": 24593},
      {"name": "AxisGridLine", "value": 652},
      {"name": "AxisLabel", "value": 636},
      {"name": "CartesianAxes", "value": 6703}
     ]
    },
    {
     "name": "controls",
     "children": [
      {"name": "AnchorControl", "value": 2138},
      {"name": "ClickControl", "value": 3824},
      {"name": "Control", "value": 1353},
      {"name": "ControlList", "value": 4665},
      {"name": "DragControl", "value": 2649},
      {"name": "ExpandControl", "value": 2832},
      {"name": "HoverControl", "value": 4896},
      {"name": "IControl", "value": 763},
      {"name": "PanZoomControl", "value": 5222},
      {"name": "SelectionControl", "value": 7862},
      {"name": "TooltipControl", "value": 8435}
     ]
    },
    {
     "name": "data",
     "children": [
      {"name": "Data", "value": 20544},
      {"name": "DataList", "value": 19788},
      {"name": "DataSprite", "value": 10349},
      {"name": "EdgeSprite", "value": 3301},
      {"name": "NodeSprite", "value": 19382},
      {
       "name": "render",
       "children": [
        {"name": "ArrowType", "value": 698},
        {"name": "EdgeRenderer", "value": 5569},
        {"name": "IRenderer", "value": 353},
        {"name": "ShapeRenderer", "value": 2247}
       ]
      },
      {"name": "ScaleBinding", "value": 11275},
      {"name": "Tree", "value": 7147},
      {"name": "TreeBuilder", "value": 9930}
     ]
    },
    {
     "name": "events",
     "children": [
      {"name": "DataEvent", "value": 2313},
      {"name": "SelectionEvent", "value": 1880},
      {"name": "TooltipEvent", "value": 1701},
      {"name": "VisualizationEvent", "value": 1117}
     ]
    },
    {
     "name": "legend",
     "children": [
      {"name": "Legend", "value": 20859},
      {"name": "LegendItem", "value": 4614},
      {"name": "LegendRange", "value": 10530}
     ]
    },
    {
     "name": "operator",
     "children": [
      {
       "name": "distortion",
       "children": [
        {"name": "BifocalDistortion", "value": 4461},
        {"name": "Distortion", "value": 6314},
        {"name": "FisheyeDistortion", "value": 3444}
       ]
      },
      {
       "name": "encoder",
       "children": [
        {"name": "ColorEncoder", "value": 3179},
        {"name": "Encoder", "value": 4060},
        {"name": "PropertyEncoder", "value": 4138},
        {"name": "ShapeEncoder", "value": 1690},
        {"name": "SizeEncoder", "value": 1830}
       ]
      },
      {
       "name": "filter",
       "children": [
        {"name": "FisheyeTreeFilter", "value": 5219},
        {"name": "GraphDistanceFilter", "value": 3165},
        {"name": "VisibilityFilter", "value": 3509}
       ]
      },
      {"name": "IOperator", "value": 1286},
      {
       "name": "label",
       "children": [
        {"name": "Labeler", "value": 9956},
        {"name": "RadialLabeler", "value": 3899},
        {"name": "StackedAreaLabeler", "value": 3202}
       ]
      },
      {
       "name": "layout",
       "children": [
        {"name": "AxisLayout", "value": 6725},
        {"name": "BundledEdgeRouter", "value": 3727},
        {"name": "CircleLayout", "value": 9317},
        {"name": "CirclePackingLayout", "value": 12003},
        {"name": "DendrogramLayout", "value": 4853},
        {"name": "ForceDirectedLayout", "value": 8411},
        {"name": "IcicleTreeLayout", "value": 4864},
        {"name": "IndentedTreeLayout", "value": 3174},
        {"name": "Layout", "value": 7881},
        {"name": "NodeLinkTreeLayout", "value": 12870},
        {"name": "PieLayout", "value": 2728},
        {"name": "RadialTreeLayout", "value": 12348},
        {"name": "RandomLayout", "value": 870},
        {"name": "StackedAreaLayout", "value": 9121},
        {"name": "TreeMapLayout", "value": 9191}
       ]
      },
      {"name": "Operator", "value": 2490},
      {"name": "OperatorList", "value": 5248},
      {"name": "OperatorSequence", "value": 4190},
      {"name": "OperatorSwitch", "value": 2581},
      {"name": "SortOperator", "value": 2023}
     ]
    },
    {"name": "Visualization", "value": 16540}
   ]
  }
 ]
};

		// 调整布局
		function firstWalk(node){
			// var space = 65;
			// var nodeSize = 30;
			var space = 40;
			var nodeSize = 20;
			if(node.children == null)
			{	// 判断该节点是否有子节点
				// 如果当前节点为叶子节点
				if(node.leftsiblingId!=null)
				{
					// 该节点有左兄弟，计算相对位置
					node.prelim = data[node.leftsiblingId].prelim + space + nodeSize;
				}
				else  //如果该节点没有左兄弟prelim记为0
				{
					node.prelim = 0 ;
				}
			}
			else // 计算非叶子节点
			{
				// 先计算所有子节点的位置
				var leftPrelim = 0;
				var rightPrelim =0;
				var nodeChild = null
				nodeChild = node.children[0];    // 一个节点的最左孩子
				firstWalk(nodeChild);
				leftPrelim = node.children[0].prelim;
				
				while(nodeChild.rightSiblingId!=null&&nodeChild.rightSiblingId!=undefined)
				{
					nodeChild = data[nodeChild.rightSiblingId]
					firstWalk(nodeChild);
				}
				rightPrelim = nodeChild.prelim;
				var midPoint = (leftPrelim + rightPrelim)/2   // 定位到子节点集合的中心位置

				// 如果当前节点有左兄弟，prelim计算相对位置,计算modifier
				if(node.leftsiblingId!=null)
				{

					node.prelim = data[node.leftsiblingId].prelim +space +nodeSize;
					node.modifier = node.prelim - midPoint;

					// 计算子树移动距离,当前深度节点分摊偏移
					apportion(node);
				}
				else  // 没有左兄弟，prelim记子节点集合的中心位置
				{
					node.prelim = midPoint;
				}
			}
		}

		function secondWalk(modSom,node){
			if(node!=null)
			{
				// 根据prelim和偏移值计算x，根据深度计算y
				node.x = node.prelim + modSom;
				node.y = node.level *300+40;


				// 遍历子节点，子节点的偏移累加父节点prelim
				if(node.children!=null)
				{//子节点不等于空

					for(var j=0;j<node.children.length;j++)
					{
						var modifier = 0
						if(node.modifier!=null&&node.modifier!=undefined)
							modifier =node.modifier
						
						secondWalk(modSom+modifier,node.children[j])
					
					}
				}
			}
		}


		function getLeftMost(node,level,depth){
			if(depth <= level)
				return node;
			else if(node.children == null||node.children==undefined)
				return null;
			else
			{
				var rightMost = node.children[0];
				leftMost = getLeftMost(rightMost, level + 1,depth)
				while(leftMost==null && rightMost.rightSiblingId!=null)
				{
					rightMost = data[rightMost.rightSiblingId];
					leftMost = getLeftMost(rightMost , level + 1,depth)
				}
				return leftMost;
			}
			
		}

		function apportion(node){
			
			var leftMost = null;
			var neighbor = null;
			leftMost = node.children[0];            // 当前节点下移一行，取最左孩子

			neighbor = data[leftMost.leftNeighbor]; //下移后左节点的左邻居，进行比较
			var CompareDepth = 1;
			var leftModSum,rightModSum;
			while (leftMost!=null&&neighbor!=null)
			{
			
				// 左孩子和左孩子节点的邻居节点都存在
				// 这两个节点都在，可以进行比较，累加其父节点的modifier（即理想位置）
				leftModSum = 0.0;
				rightModSum = 0.0;


				var ancestorLeftmost = null;
				var ancestorNeighbor = null;
				ancestorLeftmost = leftMost;
				ancestorNeighbor = neighbor;


				// 从子节点往上遍历到当前深度
				for (var i=0;i<CompareDepth;i++)
				{
					// 下移一个深度
					ancestorLeftmost = data[ancestorLeftmost.fatherId];
					ancestorNeighbor = data[ancestorNeighbor.fatherId];

					// console.log(i+node.name+"他的ancestorLeftmost节点为"+ancestorLeftmost.name+"、他的ancestorNeighbor节点为"+ancestorNeighbor.name)
					if(ancestorLeftmost==null||ancestorNeighbor==null)
						continue;
					rightModSum += ancestorLeftmost.modifier;
					leftModSum += ancestorNeighbor.modifier;
					
				}

				var moveDistance = (neighbor.prelim + leftModSum + 80) - (leftMost.prelim + rightModSum);

				// 计算后应向右偏移，当前列的所以节点分摊右移
				if(moveDistance > 0.0)
				{
					var tempPtr = null;
					tempPtr = node;
					var leftsibling = 0;
					//往左数到子节点邻居的父节点
					while(tempPtr!=null &&ancestorNeighbor!=null&& tempPtr.id!=ancestorNeighbor.id)
					{
						// 主要用于检测有几个兄弟（用于计算分摊的偏移量）
						leftsibling = leftsibling + 1;
						tempPtr = data[tempPtr.leftsiblingId];
					}
					// leftsibling = data[tempPtr.fatherId].children.length

					//从当前节点到邻居父节点，对所有节点进行移位
					if(tempPtr!=null)
					{
						var portion = moveDistance/leftsibling;
						tempPtr = node;
						while(tempPtr!=null &&ancestorNeighbor!=null&&tempPtr!=ancestorNeighbor)    
						{
							tempPtr.prelim = tempPtr.prelim + moveDistance;
							tempPtr.modifier = tempPtr.modifier + moveDistance;
							moveDistance = moveDistance - portion;
							tempPtr = data[tempPtr.leftsiblingId];
						}
					}
					else
					{
						// return;
					}
				}
				CompareDepth += 1;
				if(leftMost.children==null)        //leftMost.children[0]==null||leftMost.children[0]==undefined||
				{								   //当前深度，查找第一个有子节点的，取最左子节点
					// console.log(111)
					// console.log(leftMost);
					leftMost = getLeftMost(node,0,CompareDepth)
					// console.log(leftMost)
				}
				else
					leftMost = leftMost.children[0];
				if (leftMost!=null&&leftMost.leftNeighbor!=null)
					neighbor = data[leftMost.leftNeighbor]
			}
		}





		function NodeInit(x,y,size,nodeText,nodeType){
			var c = document.getElementById('myCanvas')
			var ctx1=c.getContext("2d");
			ctx1.fillStyle = "rgb(7,105,173)";
			if(nodeType=="Root")
			{
				
				ctx1.fillRect(x-size/2,y-size/2,size,size);
				ctx1.globalCompositeOperation = "destination-over"; //全局合成操作

				// 绘制文字
				ctx1.font="15px Arial";
				ctx1.fillText(nodeText, x+size/2+5, y+size/2-5);
			}
			else if(nodeType=="Node")
			{
				
				ctx1.beginPath();
			    ctx1.arc(x,y,size,0,Math.PI*2);
			    ctx1.closePath();
			    ctx1.fill();

			    // 绘制文字
				ctx1.font="15px Arial";
				ctx1.fillText(nodeText, x+size+5, y+size/2+5);
			}
		}

 		
 		// 正常树状线
		function EdgInit(beginX,beginY,endX,endY){
			var ctx1 = document.getElementById("myCanvas").getContext("2d");
			ctx1.beginPath();
			ctx1.moveTo(beginX, beginY);
			ctx1.lineTo(endX,endY);
			ctx1.lineWidth=1;
			ctx1.strokeStyle="black";
			ctx1.stroke();
			ctx1.closePath();
		}

		// 垂直树状线
		function EdgInit2(beginX,beginY,endX,endY)
		{
			var horizontalSpace =100 ;
			var ctx1 = document.getElementById("myCanvas").getContext("2d");
			ctx1.beginPath();
			ctx1.moveTo(beginX, beginY);
			ctx1.lineTo(beginX,beginY-horizontalSpace/2)
			ctx1.lineTo(endX,beginY-horizontalSpace/2)
			ctx1.lineTo(endX,endY);
			ctx1.lineWidth=1;
			ctx1.strokeStyle="black";
			ctx1.stroke();
			ctx1.closePath();
		}


		function disposalData(root,data)
		{
			if(root!=null&&root!=undefined)
			{
				if(root.children!=null)
				{
					for(var i=0;i<root.children.length;i++)
					{
						data[data.length] = root.children[i]
						//data[data.length].id = data.length
					}
					for(var i=0;i<root.children.length;i++)
					{
						disposalData(root.children[i],data)
					}
				}

			}
		}

		// 递归函数，自根节点开始(深度优先遍历)
		function UpdateData(data){
			UpdataNode(data[0])
		}	


		function UpdataNode(root){ // 深度优先遍历
			// 改变更新系统的深度
			if (root.fatherId == -1)
			{
				root.level = 0;
			}
			else
			{
				root.level = data[root.fatherId].level + 1
			}
			if(root.children!=null)
			{//子节点不等于空

				for(var j=0;j<root.children.length;j++)
				{
					if(j+1<root.children.length)
					{
						root.children[j].rightSiblingId = root.children[j+1].id;
						root.children[j+1].leftsiblingId = root.children[j].id;
					}
					UpdataNode(root.children[j])
				}
			}
		}

		function levelFirst(data,arr)
		{
			// 层序遍历
			// 实例化队列
			arr.push(data[0].id)
			levelNode(arr,0,data)
			//console.log(arr)

		}
		// 层序遍历
		function levelNode(items,index,data){
			// 弹出栈元素
			root =	null
			root = (data[items[index]])
			
			if(root!=null)
			{
			// 根节点入栈
				if(root.children!=null)
				{//子节点不等于空
					for (var j=0;j<root.children.length;j++)
					{
						items.push(root.children[j].id)
					}		
				}
			levelNode(items,index+1,data)	
			}
		}

		function FindleftNeighbor(data,arr){
			// 该函数用于确定最左节点（非兄弟）
			for(var i=1;i<arr.length;i++)
			{
				// 判断有没有跟该节点同层的节点
				if(data[arr[i]].level==data[arr[i-1]].level)
				{
					if(data[arr[i]].leftsiblingId != data[arr[i-1]].id)
					{
						//判断这些节点的左邻节点是否是他们的兄弟节点
						data[arr[i]].leftNeighbor = data[arr[i-1]].id
					}
					else
					{
						//console.log(data[arr[i]].name)
					}
				}
				else
				{
					// 这些节点已经是本层最左侧节点，故不存在同级左节点
					//console.log(data[arr[i]].name)
				}

			}
		}





		let data = []
		data[0] = tree
		data[0].id = "0"
		disposalData(tree,data)

		//console.log(data)

		for (var i=0;i<data.length;i++)
		{
			data[i].id = i;
			data[i].level = 0;
			data[i].prelim = 0;
			data[i].modifier =0;
		}
		for(var i =0 ;i<data.length;i++)
		{
			if(i==0)
			{
				data[i].fatherId = -1
			}
			if(data[i].children!=null)
			{
				for(var j=0;j<data[i].children.length;j++)
				{
					data[i].children[j].fatherId = i
				}
			}

		}
		UpdateData(data)


		let arr = [];
		levelFirst(data,arr)
		FindleftNeighbor(data,arr)


		firstWalk(data[0]);
		secondWalk(90,data[0]);


		//生成节点
		for(var i=0;i<data.length;i++)
		{
			//生成节点
			if (i==0) {
				NodeInit(data[i].x,data[i].y,30,data[i].name,"Root")
			}
			else
			{
				NodeInit(data[i].x,data[i].y,20,data[i].name,"Node")
			}
			
		}


		//生成连线
		//子找父
		for(var i=0;i<data.length;i++)
		{
			if(data[i].fatherId>=0)
			{
				EdgInit(data[i].x , data[i].y , data[parseInt(data[i].fatherId)].x , data[parseInt(data[i].fatherId)].y);
			}
		}
        console.log(data)

			

</script>
</body>
</html>